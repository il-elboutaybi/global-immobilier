"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSnapshotFromFile = exports.parseSnapshot = void 0;
const oboe = require("oboe");
const fs = require("fs");
function hasDetachedness(data) {
    return data.snapshot.meta.node_fields.length >= 7;
}
function parseInfoFromSnapshot(data) {
    return {
        nodeFieldCount: data.snapshot.meta.node_fields.length,
        edgeFieldCount: data.snapshot.meta.edge_fields.length,
    };
}
var Sanity;
(function (Sanity) {
    class Optional {
        constructor(value) {
            this.value = value;
        }
    }
    function opt(x) {
        return new Optional(x);
    }
    const nodeTypeTypesProto = [
        "hidden",
        "array",
        "string",
        "object",
        "code",
        "closure",
        "regexp",
        "number",
        "native",
        "synthetic",
        "concatenated string",
        "sliced string",
        "symbol",
        "bigint",
        opt("object shape"),
        opt("wasm object"),
    ];
    const metaDataProto = {
        node_fields: [
            "type",
            "name",
            "id",
            "self_size",
            "edge_count",
            "trace_node_id",
            opt("detachedness"),
        ],
        node_types: [
            nodeTypeTypesProto,
            "string",
            "number",
            "number",
            "number",
            "number",
            opt("number"),
        ],
        edge_fields: ["type", "name_or_index", "to_node"],
        edge_types: [
            [
                "context",
                "element",
                "property",
                "internal",
                "hidden",
                "shortcut",
                "weak",
            ],
            "string_or_number",
            "node",
        ],
        trace_function_info_fields: [
            "function_id",
            "name",
            "script_name",
            "script_id",
            "line",
            "column",
        ],
        trace_node_fields: [
            "id",
            "function_info_index",
            "count",
            "size",
            "children",
        ],
        sample_fields: ["timestamp_us", "last_assigned_id"],
        location_fields: ["object_index", "script_id", "line", "column"],
    };
    function assertX(desc, cond) {
        if (!cond) {
            throw new Error(desc);
        }
    }
    function assertObject(path, x) {
        assertX(`${path} is not an object, but is ${typeof x}`, typeof x === "object");
    }
    function assertArray(path, arr) {
        assertX(`${path} is not an array, but is '${typeof arr}'`, Array.isArray(arr));
    }
    function assertInteger(path, n) {
        assertX(`${path} is not an integer, but is '${typeof n}'`, Number.isInteger(n));
    }
    function assertLength(name, len, expectedLen) {
        if (len !== expectedLen) {
            throw new Error(`But Expected ${expectedLen} ${name}, but got ${len}`);
        }
    }
    function checkMetaData(path, data, proto) {
        let ok = true;
        if (proto instanceof Optional) {
            if (data !== undefined) {
                ok = checkMetaData(path, data, proto.value);
            }
        }
        else if (typeof proto === "string") {
            if (proto !== data) {
                console.warn(`Expected '${path}' to be '${proto}' but was '${data}'!`);
                ok = false;
            }
        }
        else if (Array.isArray(proto)) {
            if (!Array.isArray(data)) {
                console.warn(`Expected '${path}' to be an array but was ${JSON.stringify(data)}!`);
                return false;
            }
            if (data.length > proto.length) {
                console.warn(`Array at '${path}' has ${data.length - proto.length} new element!`);
                for (let idx = proto.length; idx < data.length; ++idx) {
                    console.warn(`- At index ${idx}: ${JSON.stringify(data[idx])}`);
                }
                ok = false;
            }
            for (let idx = 0; idx < proto.length; ++idx) {
                ok = checkMetaData(`${path}[${idx}]`, data[idx], proto[idx]) && ok;
            }
        }
        else {
            if (Array.isArray(data) || typeof data !== "object") {
                console.warn(`Expected '${path}' to be an object but was ${JSON.stringify(data)}!`);
                return false;
            }
            for (let prop in proto) {
                ok = checkMetaData(`${path}.${prop}`, data[prop], proto[prop]) && ok;
            }
        }
        return ok;
    }
    function check(data) {
        // assert root
        assertObject("data", data);
        // assert root properties
        assertArray("data.nodes", data.nodes);
        assertArray("data.edges", data.edges);
        assertArray("data.strings", data.strings);
        assertArray("data.trace_function_infos", data.trace_function_infos);
        assertArray("data.trace_tree", data.trace_tree);
        assertArray("data.samples", data.samples);
        // assert snapshot
        const snapshot = data.snapshot;
        assertInteger("data.snapshot.node_count", snapshot.node_count);
        assertInteger("data.snapshot.edge_count", snapshot.edge_count);
        assertInteger("data.snapshot.trace_function_count", snapshot.trace_function_count);
        const meta = snapshot.meta;
        assertObject("data.snapshot.meta", snapshot.meta);
        assertX("data.snapshot.meta.node_fields must have same length as data.snapshot.meta.node_types", meta.node_fields.length == meta.node_types.length);
        assertX("data.snapshot.meta.edge_fields must have same length as data.snapshot.meta.edge_types", meta.edge_fields.length == meta.edge_types.length);
        // assert ParseInfo
        const parseInfo = parseInfoFromSnapshot(data);
        assertX(`expected at least 6 node fields, but got ${parseInfo.nodeFieldCount}`, parseInfo.nodeFieldCount >= 6);
        assertLength("edge fields", parseInfo.edgeFieldCount, 3);
        const ok = checkMetaData("data.snapshot.meta", meta, metaDataProto);
        if (!ok) {
            console.error("Heapsnapshot format changed! Please report to https://github.com/SrTobi/v8-heapsnapshot/issues");
            console.error("Continuing anyway... :)");
        }
        // assert elemnt counts
        assertLength("node elements", data.nodes.length, snapshot.node_count * meta.node_fields.length);
        assertLength("edge elements", data.edges.length, snapshot.edge_count * meta.edge_fields.length);
        assertLength("trace function elements", data.trace_function_infos.length, snapshot.trace_function_count * meta.trace_function_info_fields.length);
    }
    Sanity.check = check;
})(Sanity || (Sanity = {}));
class NodeImpl {
    constructor(type, name, id, self_size, edge_count, trace_node_id, detached) {
        this.type = type;
        this.name = name;
        this.id = id;
        this.self_size = self_size;
        this.edge_count = edge_count;
        this.trace_node_id = trace_node_id;
        this.detached = detached;
        this.out_edges = [];
        this.in_edges = [];
    }
    toString() {
        return `${this.name}[${this.type}]@${this.id}`;
    }
    toLongString() {
        return `${this.name}[${this.type}]@${this.id}{${this.out_edges.join(", ")}}`;
    }
    print(deep = 2, indent = 0, edge_prefix) {
        console.log("|" + Array(indent + 1).join("  ") + (edge_prefix || "") + this.toString());
        if (deep > 0) {
            for (const e of this.out_edges) {
                e.to.print(deep - 1, indent + 1, `[${e.type}]${e.name} -> `);
            }
        }
    }
}
class EdgeImpl {
    constructor(type, name, from, to) {
        this.type = type;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    toString() {
        return `[${this.type}]${this.name} -> ${this.to}`;
    }
    toLongString() {
        return `[${this.type}]${this.name} -> ${this.to.toLongString()}`;
    }
}
class SnapshotImpl {
    constructor(nodes, edges, hasDetachedness) {
        this.nodes = nodes;
        this.edges = edges;
        this.hasDetachedness = hasDetachedness;
        this.idToNodeMapping = new Map();
        nodes.forEach((node) => this.idToNodeMapping.set(node.id, node));
    }
    findNodeById(id) {
        return this.idToNodeMapping.get(id);
    }
    get global() {
        if (!this._global) {
            this._global = this.nodes.find((node) => node.name === "global / ");
            if (!this._global) {
                throw new Error("Could not find global object!");
            }
        }
        return this._global;
    }
    get modules() {
        if (!this._modules) {
            this._modules = this.nodes.filter((node) => node.name === "Module" && node.type === "object");
        }
        return this._modules;
    }
}
function access(arr, idx, baseIdx, length, f) {
    return idx - baseIdx < length ? f(arr[idx]) : undefined;
}
function parseNodes(data, parseInfo) {
    const nodes = data.nodes;
    const strings = data.strings;
    const types = data.snapshot.meta.node_types[0];
    const result = [];
    const nodeFieldCount = parseInfo.nodeFieldCount;
    for (let nodeIndex = 0; nodeIndex < data.snapshot.node_count; ++nodeIndex) {
        const baseIndex = nodeIndex * nodeFieldCount;
        let dataIndex = baseIndex;
        const node = new NodeImpl(types[nodes[dataIndex++]], strings[nodes[dataIndex++]], nodes[dataIndex++], nodes[dataIndex++], nodes[dataIndex++], nodes[dataIndex++], access(nodes, dataIndex++, baseIndex, nodeFieldCount, (num) => num == 1));
        result.push(node);
    }
    return result;
}
function parseAndWireEdges(data, nodes, parseInfo) {
    const result = [];
    const edges = data.edges;
    const strings = data.strings;
    const types = data.snapshot.meta.edge_types[0];
    function name_or_index(type, i) {
        if (type == "element" || type == "hidden") {
            return i;
        }
        if (i >= strings.length) {
            throw new Error("Invalid string index!");
        }
        return strings[i];
    }
    const nodeFieldCount = parseInfo.nodeFieldCount;
    let edgeIndex = 0;
    nodes.forEach((from_node) => {
        for (let edgeCount = 0; edgeCount < from_node.edge_count; ++edgeCount) {
            const type = types[edges[edgeIndex++]];
            const name = name_or_index(type, edges[edgeIndex++]);
            const to_node = nodes[edges[edgeIndex++] / nodeFieldCount];
            const edge = new EdgeImpl(type, name, from_node, to_node);
            result.push(edge);
            from_node.out_edges.push(edge);
            to_node.in_edges.push(edge);
        }
    });
    return result;
}
function parseSnapshot(arg1) {
    return __awaiter(this, void 0, void 0, function* () {
        let data;
        if (typeof arg1 === "string") {
            data = JSON.parse(arg1);
        }
        else if (arg1 instanceof fs.ReadStream) {
            data = yield new Promise((resolve, reject) => {
                oboe(arg1).node("!", resolve).fail(reject);
            });
        }
        else if (typeof arg1 === "object") {
            data = arg1;
        }
        else {
            throw new Error("Illigal snapshot data!");
        }
        Sanity.check(data);
        const parseInfo = parseInfoFromSnapshot(data);
        const nodes = parseNodes(data, parseInfo);
        const edges = parseAndWireEdges(data, nodes, parseInfo);
        return new SnapshotImpl(nodes, edges, hasDetachedness(data));
    });
}
exports.parseSnapshot = parseSnapshot;
function parseSnapshotFromFile(filename, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const stream = fs.createReadStream(filename, options);
        return yield parseSnapshot(stream);
    });
}
exports.parseSnapshotFromFile = parseSnapshotFromFile;
/*async function main() {
  console.log("Run...");
  const snapshot = await parseSnapshotFromFile(
    process.argv[2] || "blub.js.heapsnapshot"
  );
  console.log("nodes:", snapshot.nodes.length);
  console.log("edges:", snapshot.edges.length);

  debugger;
}

main();
*/
//# sourceMappingURL=index.js.map